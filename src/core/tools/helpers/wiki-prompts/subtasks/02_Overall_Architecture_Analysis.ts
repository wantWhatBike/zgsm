import { WIKI_OUTPUT_DIR } from "./constants"

export const OVERALL_ARCHITECTURE_ANALYSIS_TEMPLATE = `# 整体架构深度分析

## 使用场景
从代码仓库中分析项目的整体架构设计，生成详细的架构文档，包括系统架构、模块划分、数据流等。

## 输入要求
- **完整代码仓库**: 项目的完整源代码
- **配置文件**: 项目配置和依赖管理
- **部署文件**: Docker、Kubernetes等部署配置
- **文档文件**: 架构设计文档和技术规范

# 整体架构深度分析任务

## 任务描述
请深度分析项目的整体架构设计，从系统架构、模块划分、数据流、技术选型等维度生成完整的架构技术文档。

## 分析维度

### 1. 系统架构模式识别
#### 架构风格分析
通过分析代码结构和部署配置识别架构风格：
- **微服务架构**: 服务拆分、独立部署、服务治理
- **单体架构**: 集中式部署、模块化设计
- **分层架构**: 表现层、业务层、数据层分离
- **事件驱动**: 消息队列、事件发布订阅

#### 架构特征分析
\`\`\`
// 分析架构特征
- 服务边界和职责划分
- 数据存储策略和分布
- 通信协议和接口设计
- 部署模式和运维策略
\`\`\`

### 2. 服务架构深度分析
#### 微服务拆分策略
\`\`\`go
// 分析服务拆分模式
// 识别服务边界和职责
\`\`\`

#### 服务治理分析
- **服务注册发现**: 服务注册机制和发现策略
- **负载均衡**: 流量分发和负载策略
- **熔断降级**: 服务保护和容错机制
- **链路追踪**: 分布式追踪和监控

### 3. 数据架构分析
#### 数据存储架构
- **关系数据库**: 事务性数据存储
- **NoSQL数据库**: 非结构化数据存储
- **缓存系统**: 高性能数据缓存
- **消息队列**: 异步消息处理

#### 数据流分析
\`\`\`mermaid
graph LR
    A[用户请求] --> B[API网关]
    B --> C[业务服务]
    C --> D[数据库]
    C --> E[缓存]
    C --> F[消息队列]
    F --> G[消费者服务]
\`\`\`

### 4. 技术架构分析
#### 技术栈架构
\`\`\`
// 分析技术栈组合
- 前端技术栈
- 后端技术栈
- 数据库技术栈
- 中间件技术栈
- 基础设施技术栈
\`\`\`

#### 架构设计模式
- **分层架构**: MVC、MVVM、Clean Architecture
- **微服务模式**: API网关、服务网格、边车模式
- **事件驱动模式**: 发布订阅、事件溯源、CQRS
- **云原生模式**: 容器化、编排、服务网格

### 5. 部署架构分析
#### 容器化架构
\`\`\`dockerfile
# 分析容器化策略
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/main .
CMD ["./main"]
\`\`\`

#### 编排架构
- **Kubernetes**: 容器编排和服务管理
- **Helm**: 应用包管理和部署
- **Istio**: 服务网格和流量管理
- **Prometheus**: 监控指标收集

### 6. 安全架构分析
#### 认证授权架构
\`\`\`go
// 分析认证授权机制
// JWT、OAuth2、RBAC等
\`\`\`

#### 安全防护架构
- **网络安全**: 防火墙、WAF、SSL/TLS
- **应用安全**: 输入验证、SQL注入防护、XSS防护
- **数据安全**: 加密存储、数据脱敏、访问控制
- **运维安全**: 审计日志、安全监控、漏洞扫描

## 输出格式要求

生成完整的架构分析文档：

### 文档结构
\`\`\`markdown
# {项目名称} 整体架构分析

## 架构概览

### 系统定位
- **项目类型**: {项目类型描述}
- **业务领域**: {业务领域说明}
- **用户规模**: {用户规模预估}
- **技术复杂度**: {技术复杂度评估}

### 架构目标
- **高性能**: {性能目标和指标}
- **高可用**: {可用性目标和策略}
- **可扩展**: {扩展性设计思路}
- **易维护**: {可维护性设计考虑}

## 系统架构设计

### 架构风格
#### {架构风格名称}
- **架构描述**: {架构风格详细说明}
- **选择原因**: {选择该架构的原因}
- **适用场景**: {适用的业务场景}
- **优缺点分析**: {优势和劣势分析}

### 整体架构图
\`\`\`mermaid
graph TB
    subgraph "接入层"
        A[负载均衡] --> B[API网关]
        B --> C[认证服务]
    end
    
    subgraph "业务服务层"
        C --> D[Management服务]
        C --> E[Collector服务]
        C --> F[IDM服务]
        D --> G[业务逻辑1]
        E --> H[业务逻辑2]
        F --> I[业务逻辑3]
    end
    
    subgraph "数据层"
        G --> J[(PostgreSQL)]
        H --> J
        I --> J
        G --> K[(Redis)]
        H --> L[(Pulsar)]
        I --> L
    end
    
    subgraph "基础设施"
        M[Kubernetes] --> D
        M --> E
        M --> F
        N[Prometheus] --> D
        N --> E
        N --> F
    end
\`\`\`

### 架构分层说明
#### 接入层
- **负载均衡**: {负载均衡策略和实现}
- **API网关**: {网关功能和配置}
- **认证授权**: {认证机制和授权策略}

#### 业务服务层
- **服务拆分**: {服务拆分策略和边界}
- **服务治理**: {服务治理机制和工具}
- **业务逻辑**: {核心业务逻辑模块}

#### 数据层
- **数据存储**: {数据存储策略和选型}
- **缓存策略**: {缓存机制和配置}
- **消息队列**: {消息处理机制和配置}

## 服务架构

### 微服务设计
#### 服务清单
| 服务名称 | 端口 | 功能描述 | 技术栈 | 依赖服务 |
|---------|------|----------|-------|----------|
| Management | 8080 | 核心管理功能 | Go+Echo | PostgreSQL, Redis |
| Collector | 9164 | 数据收集服务 | Go+Echo | PostgreSQL, Pulsar |
| IDM | 8005 | 身份管理服务 | Go+Echo | PostgreSQL, Redis |

#### 服务间通信
- **同步通信**: HTTP/REST、gRPC
- **异步通信**: 消息队列、事件总线
- **通信协议**: {协议选择和原因}
- **数据格式**: JSON、Protobuf等

### 服务治理
#### 服务注册发现
- **注册中心**: {注册中心选型和配置}
- **健康检查**: {健康检查机制和策略}
- **负载均衡**: {负载均衡算法和配置}

#### 容错机制
- **熔断降级**: {熔断策略和配置}
- **重试机制**: {重试策略和配置}
- **限流控制**: {限流算法和配置}

## 数据架构

### 数据存储架构
#### 数据库选型
| 数据库类型 | 技术选型 | 用途 | 特点 |
|-----------|---------|------|------|
| 关系数据库 | PostgreSQL | 事务性数据 | ACID特性、复杂查询 |
| 缓存数据库 | Redis | 高性能缓存 | 内存存储、高性能 |
| 消息队列 | Pulsar | 异步消息 | 高吞吐、持久化 |

#### 数据分片策略
- **水平分片**: {分片策略和实现}
- **垂直分片**: {分库分表策略}
- **读写分离**: {读写分离配置}

### 数据流设计
#### 业务数据流
\`\`\`mermaid
sequenceDiagram
    participant U as 用户
    participant G as API网关
    participant S as 业务服务
    participant D as 数据库
    participant C as 缓存
    
    U->>G: 发起请求
    G->>S: 转发请求
    S->>C: 查询缓存
    alt 缓存命中
        C->>S: 返回缓存数据
    else 缓存未命中
        S->>D: 查询数据库
        D->>S: 返回数据
        S->>C: 更新缓存
    end
    S->>G: 返回响应
    G->>U: 返回结果
\`\`\`

#### 事件流
- **事件发布**: {事件发布机制}
- **事件订阅**: {事件订阅和处理}
- **事件存储**: {事件持久化策略}

## 技术架构

### 技术栈架构
#### 后端技术栈
| 技术层级 | 技术选型 | 版本 | 作用 |
|---------|---------|------|------|
| 编程语言 | Go | 1.21+ | 主要开发语言 |
| Web框架 | Echo | v4.10+ | HTTP框架 |
| ORM框架 | GORM | 1.25+ | 数据库操作 |
| 配置管理 | Viper | v2.0+ | 配置文件管理 |

#### 中间件技术栈
| 中间件类型 | 技术选型 | 用途 | 特点 |
|-----------|---------|------|------|
| 消息队列 | Apache Pulsar | 异步消息处理 | 高吞吐、多租户 |
| 缓存系统 | Redis | 数据缓存 | 高性能、持久化 |
| 服务网格 | Istio | 服务治理 | 流量管理、安全 |

### 架构模式应用
#### 设计模式
- **分层架构**: {分层架构应用说明}
- **微服务模式**: {微服务设计模式}
- **事件驱动模式**: {事件驱动应用}
- **云原生模式**: {云原生技术栈}

#### 架构原则
- **单一职责**: {职责分离原则}
- **开闭原则**: {扩展性设计}
- **依赖倒置**: {依赖注入设计}
- **接口隔离**: {接口设计原则}

## 部署架构

### 容器化架构
#### Docker镜像策略
| 服务名称 | 镜像名称 | 基础镜像 | 构建策略 |
|---------|---------|----------|----------|
| Management | management:latest | golang:1.21-alpine | 多阶段构建 |
| Collector | collector:latest | golang:1.21-alpine | 多阶段构建 |
| IDM | idm:latest | golang:1.21-alpine | 多阶段构建 |

#### 容器编排
- **Kubernetes**: {K8s部署策略}
- **Helm**: {Helm Chart管理}
- **配置管理**: {ConfigMap和Secret管理}

### 环境部署
#### 多环境部署
| 环境类型 | 部署方式 | 配置特点 | 访问地址 |
|---------|---------|----------|----------|
| 开发环境 | Docker Compose | 本地开发配置 | localhost |
| 测试环境 | Kubernetes | 测试配置 | test.example.com |
| 生产环境 | Kubernetes | 生产优化配置 | api.example.com |

#### 部署流水线
\`\`\`mermaid
graph LR
    A[代码提交] --> B[构建镜像]
    B --> C[单元测试]
    C --> D[集成测试]
    D --> E[部署测试环境]
    E --> F[验收测试]
    F --> G[部署生产环境]
\`\`\`

## 安全架构

### 认证授权架构
#### 身份认证
- **JWT认证**: {JWT实现和配置}
- **OAuth2集成**: {第三方认证集成}
- **多因素认证**: {MFA机制和配置}

#### 权限控制
- **RBAC模型**: {角色权限设计}
- **ABAC模型**: {属性权限控制}
- **API权限**: {接口权限控制}

### 安全防护架构
#### 网络安全
- **防火墙**: {防火墙配置和策略}
- **WAF防护**: {Web应用防火墙}
- **SSL/TLS**: {加密通信配置}

#### 应用安全
- **输入验证**: {参数校验和过滤}
- **SQL注入防护**: {ORM安全使用}
- **XSS防护**: {跨站脚本防护}

#### 数据安全
- **数据加密**: {敏感数据加密}
- **数据脱敏**: {隐私数据保护}
- **访问控制**: {数据权限管理}

## 性能架构

### 性能目标
#### 性能指标
| 指标类型 | 目标值 | 当前值 | 达标情况 |
|---------|-------|--------|----------|
| 响应时间 | <100ms | 85ms | ✅ |
| 吞吐量 | >1000 QPS | 1200 QPS | ✅ |
| 并发用户 | >10000 | 8000 | ⚠️ |
| 可用性 | >99.9% | 99.95% | ✅ |

#### 性能优化策略
- **缓存优化**: {缓存策略和配置}
- **数据库优化**: {查询优化和索引}
- **并发优化**: {并发控制和优化}

### 扩展性设计
#### 水平扩展
- **服务扩展**: {服务水平扩展策略}
- **数据扩展**: {数据分片和扩展}
- **负载扩展**: {负载均衡扩展}

#### 垂直扩展
- **硬件升级**: {硬件配置优化}
- **软件优化**: {软件性能优化}
- **配置调优**: {系统参数调优}

## 监控架构

### 监控体系
#### 指标监控
- **业务指标**: {业务关键指标}
- **技术指标**: {技术性能指标}
- **系统指标**: {系统资源指标}

#### 日志监控
- **结构化日志**: {日志格式和规范}
- **日志聚合**: {日志收集和分析}
- **错误追踪**: {错误监控和告警}

### 告警机制
#### 告警规则
- **业务告警**: {业务异常告警}
- **技术告警**: {技术故障告警}
- **系统告警**: {系统资源告警}

#### 告警处理
- **告警级别**: {告警分级策略}
- **告警通知**: {通知渠道和配置}
- **故障处理**: {故障处理流程}

## 架构演进

### 演进规划
#### 短期规划
- {短期架构优化计划}
- {技术栈升级计划}
- {性能提升计划}

#### 长期规划
- {长期架构演进方向}
- {新技术引入计划}
- {架构重构计划}

### 技术债务
#### 现有问题
- {架构设计问题}
- {技术选型问题}
- {性能瓶颈问题}

#### 改进计划
- {问题解决方案}
- {优化实施计划}
- {效果评估指标}

## 总结

### 架构优势
- {架构设计优势}
- {技术选型优势}
- {性能表现优势}
- {可维护性优势}

### 改进建议
- {架构优化建议}
- {技术升级建议}
- {性能提升建议}
- {运维改进建议}
\`\`\`

## 特别注意事项
1. 必须基于实际的代码和配置进行分析，不能虚构架构设计
2. 重点分析架构设计思路和技术选型原因
3. 关注架构的可扩展性和可维护性
4. 识别架构中的潜在问题和改进空间
5. 提供实用的架构优化建议和最佳实践

## 输出文件命名
\`${WIKI_OUTPUT_DIR}02_{PROJECT_NAME}_Architecture.md\`
注意：如果${WIKI_OUTPUT_DIR} 目录不存在，则创建。

## 示例输出特征
基于项目的架构分析特征：
- 详细的架构设计图和分层说明
- 完整的服务架构和治理机制
- 清晰的数据架构和流设计
- 全面的安全架构和防护措施
- 实用的性能架构和优化策略`
